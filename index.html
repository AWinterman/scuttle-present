<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Andrew Winterman">
  <title>Scuttlebutt</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="style.css">
  <script type="text/javascript" async src="bundle.js"></script>
</head>
<body>
<header>
<h1 class="title">Scuttlebutt</h1>
<h2 class="author">Andrew Winterman</h2>
<h3 class="date"><em>Use up and down arrow. Scroll won’t work, really</em></h3>
</header>
<section id="who-am-i" class="level1">
<h1>Who am I?</h1>
<ul>
<li>Javascript engineer at UA.</li>
<li><a href="https://twitter.com/andywinterman">@andywinterman</a> on twitter.</li>
<li><code>winterMan</code> or sometimes <code>AWinterman</code> on IRC.</li>
<li>I like chess and mathematics :)</li>
</ul>
</section>
<section id="scuttlebutt-might-be-good-for" class="level1">
<h1>Scuttlebutt might be good for:</h1>
<ul>
<li>Real time updates across a network?</li>
<li>Multiplayer games?</li>
<li>Big Data Problems?</li>
<li>Interested in distributed systems?</li>
</ul>
</section>
<section id="let-us-talk-about-time" class="level1">
<h1>Let us talk about time:</h1>
<ul>
<li>Orders Events</li>
<li>distributed system + establishing precedence = ◔ᴗ◔</li>
<li>So we need a clock.</li>
</ul>
</section>
<section id="what-is-a-clock" class="level1">
<h1>What is a clock?</h1>
<p>A device which counts:</p>
<ul>
<li>number of electrons emitted from radon</li>
<li>drops of water</li>
<li>number of times the sun has been at a certain position</li>
<li>swings of a pendulum, etc.</li>
</ul>
<p>Why? So we have a consistent way to establish precedence:</p>
<blockquote>
<p>If an event happend at 3:15 the time on the clock was <em>after</em> 3:15, but <em>before</em> 3:16.</p>
</blockquote>
</section>
<section id="the-clock-condition" class="level1">
<h1>The Clock Condition:</h1>
<p>Given events <code>a</code> and <code>b</code>, <code>a</code> precedes <code>b</code> if <code>a</code> occurs at clock time earlier (a.k.a. lesser) than the clock time at which <code>b</code> occurs.</p>
</section>
<section id="how-do-we-establish-precedence-if-cant-both-see-the-same-clock" class="level1">
<h1>How do we establish precedence if can’t both see the same clock?</h1>
<ul>
<li>a number of processes which communicated only by message passing.</li>
<li><em>don’t</em> how long passing a message takes.</li>
<li><em>can’t</em> trust peers to keep consistent time.</li>
<li>can store data in each process</li>
</ul>
<p>What do we do?</p>
</section>
<section id="vector-clocks" class="level1">
<h1>Vector Clocks</h1>
<blockquote>
<p><em>Stay Calm</em></p>
</blockquote>
<p>Like a normal clock, measures the number of occurences of some event, but!</p>
<ul>
<li>Events occur accross a distributed system.</li>
<li>Time is unrelated to physical time.</li>
<li>Each member keeps its own clock</li>
<li>Each member keeps track of every other member’s time.</li>
</ul>
</section>
<section id="example" class="level1">
<h1>Example:</h1>
<p>A network has two nodes: <code>P</code>, <code>Q</code>, so before any events have happened:</p>
<pre><code>P: [0, 0]
Q: [0, 0]</code></pre>
<p>When <code>P</code> Recieves an event:</p>
<pre><code>P: [1, 0]
Q: [0, 0]</code></pre>
</section>
<section id="events" class="level1">
<h1>Events?</h1>
<ul>
<li>Local: at node in question</li>
<li>Send</li>
<li>Receive</li>
</ul>
</section>
<section id="implementation-rules" class="level1">
<h1>Implementation Rules</h1>
<p><strong>Rule 1:</strong> Any time a peer experiences an event, it increments its own entry in its clock.</p>
<p><strong>Rule 2:</strong> Peers must include the value, <code>t</code> of their own entry in their clock when they send messages.</p>
<p><strong>Rule 3:</strong> Upon receipt, peers update the sender’s entry in their clock to <code>t</code>. They update their own entry to be larger than <code>t</code>.</p>
</section>
<section id="example-1" class="level1">
<h1>Example:</h1>
<p>Recall:</p>
<pre><code>P: [1, 0]
Q: [0, 0]</code></pre>
<blockquote>
<p>P sends a message to Q.</p>
</blockquote>
<p>Upon sending:</p>
<pre><code>P: [2, 0]
Q: [0, 0]</code></pre>
<p>Upon Receipt:</p>
<pre><code>P: [2, 0]
Q: [1, 2]</code></pre>
</section>
<section id="how-is-this-like-time" class="level1">
<h1>How is this like time?</h1>
<p>The <a href="#the-clock-condition">clock condition</a> still holds:</p>
<p><strong>Caveat:</strong></p>
<p>This is still only a partial ordering– if messages are seldom sent, many events will appear concurrent</p>
</section>
<section id="enter-scuttlebutt" class="level1">
<h1>Enter Scuttlebutt</h1>
<blockquote>
<p>Did you hear what happened to Bob?</p>
</blockquote>
<p>Share history of state mutations accross a network.</p>
</section>
<section id="what-is-state" class="level1">
<h1>What is state?</h1>
<p>A key value store:</p>
<pre><code>{
  key1: {value: val1, version: vers1},
  key2: {value: val2, version: vers2},
  key3: {value: val3, version: vers3}
}</code></pre>
</section>
<section id="what-is-history" class="level1">
<h1>What is history?</h1>
<p>A series of entries consisting of:</p>
<ul>
<li>The event itself</li>
<li>ID of the peer at which the event the event occurred.</li>
<li>the version number of the event.</li>
</ul>
</section>
<section id="gossip-in-two-parts" class="level1">
<h1>Gossip in two parts</h1>
<section id="get-on-the-same-page" class="level3">
<h3>Get on the Same Page</h3>
<blockquote>
<p>The last time I spoke to Bob was September 2nd…</p>
</blockquote>
</section>
<section id="spilling-the-beans" class="level3">
<h3>Spilling the Beans</h3>
<blockquote>
<p>Well since then, Bob first had a baby, and then got divorced!</p>
</blockquote>
</section>
</section>
<section id="getting-on-the-same-page" class="level1">
<h1>Getting on the same page</h1>
<p>When <code>P</code> gossips with <code>Q</code>, <code>P</code> first sends a digest to <code>Q</code>:</p>
<pre><code>for(peer in network) {
  digest.queue({
      peer: peer.id
    , version: peer.largest_version_seen
  })
}</code></pre>
</section>
<section id="spilling-the-beans-1" class="level1">
<h1>Spilling the Beans</h1>
<p><code>Q</code> responds</p>
<ul>
<li>With all the updates it has seen for <code>P</code>.</li>
<li>In order of earliest timestamp first.</li>
</ul>
</section>
<section id="demo" class="level1">
<h1>Demo</h1>
</section>
<section id="when-to-apply-an-update" class="level1">
<h1>When to apply an update?</h1>
<blockquote>
<p>Here be dragons!</p>
</blockquote>
<ul>
<li>To this point discussion has been about which updates to send, and how.</li>
<li>Havent mentioned decision function for applying update to state.</li>
<li>Maybe you only care about:
<ul>
<li>The largest number any node has reported.</li>
<li>Most recent updates</li>
<li>Some union or intersection of updates</li>
</ul></li>
</ul>
</section>
<section id="questions" class="level1">
<h1>Questions?</h1>
<figure>
<img src="http://s.mlkshk.com/r/6NJJ.gif" title="wat" />
</figure>
</section>
<section id="sources" class="level1">
<h1>Sources</h1>
<p>Vector Clocks: <a href="">http://cnlab.kaist.ac.kr/~ikjun/data/Course_work/CS642-Distributed_Systems/papers/lamport1978.pdf</a></p>
<p>Scuttlebutt: <a href="">http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf</a></p>
<p>Conflicts: Everything at <a href="">http://aphyr.com/posts/281-call-me-maybe-carly-rae-jepsen-and-the-perils-of-network-partitions</a></p>
</section>
</body>
</html>
